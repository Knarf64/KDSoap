// This file is generated by KDAB's kdwsdl2cpp from transformMedia-V1_0_7.wsdl.
// All changes you do to this file will be lost.
#ifndef SOURCE_H
#define SOURCE_H

#include <QtCore/QVariant>
#include <QtCore/QString>
#include <QtCore/QSharedData>
#include <QtCore/QList>
#include <QtCore/QByteArray>
#include <KDSoapClient/KDSoapValue.h>
#include <QtCore/QStringList>
#include <KDSoapClient/KDDateTime.h>
#include <QtCore/QObject>
#include <KDSoapServer/KDSoapServerObjectInterface.h>
#include <KDSoapClient/KDSoapJob.h>
#include <KDSoapClient/KDSoapClientInterface.h>
#include <KDSoapClient/KDSoapFaultException.h>

class BMS__AncillaryDataFormatType;
class BMS__AsyncEndpointType;
class BMS__AudioFormatType;
class BMS__AudioSampleType;
class BMS__BMContentFormatType;
class BMS__BMContentFormatsType;
class BMS__BMContentType;
class BMS__BMContentsType;
class BMS__BMEssenceLocatorType;
class BMS__BMEssenceLocatorsType;
class BMS__BMObjectType;
class BMS__BMObjectsType;
class BMS__BMTrackType;
class BMS__BitRateModeType;
class BMS__CaptioningFormatType;
class BMS__CodecType;
class BMS__ContainerFormat;
class BMS__ContainerFormatType;
class BMS__ContainerMimeType;
class BMS__DataFormatType;
class BMS__DescriptionType;
class BMS__DescriptionsType;
class BMS__DurationType;
class BMS__EditUnitNumberType;
class BMS__ErrorCodeType;
class BMS__ExtensionAttributes;
class BMS__ExtensionGroup;
class BMS__FaultType;
class BMS__FormatCollection;
class BMS__FormatType;
class BMS__HashFunctionType;
class BMS__HashFunctionTypes;
class BMS__HashType;
class BMS__InnerFaultType;
class BMS__JobCommandType;
class BMS__JobInfoSelectionType;
class BMS__JobStatusType;
class BMS__JobType;
class BMS__JobsType;
class BMS__LengthType;
class BMS__ListFilterType;
class BMS__MimeType;
class BMS__PercentageProcessedCompleted;
class BMS__PriorityType;
class BMS__ProcessedInfoType;
class BMS__ProfileType;
class BMS__QueryJobRequestType;
class BMS__QueueCommandType;
class BMS__QueueStatusType;
class BMS__QueueType;
class BMS__RationalType;
class BMS__ResourceIDType;
class BMS__ResourceReferenceType;
class BMS__ResourceType;
class BMS__RevisionIDType;
class BMS__ScanningFormatType;
class BMS__ScanningOrderType;
class BMS__ServiceDescription;
class BMS__ServiceType;
class BMS__StartJobType;
class BMS__StorageType;
class BMS__StorageTypes;
class BMS__TechnicalAttributeType;
class BMS__TimecodeDuration;
class BMS__TrackConfiguration;
class BMS__TransferAtomType;
class BMS__TransformAtomType;
class BMS__UID;
class BMS__VideoFormatType;
class KDSoapMessage;
class KDSoapPendingCallWatcher;
class KDSoapValue;
class TFMS__Profiles;
class TFMS__TransformErrorCodeType;
class TFMS__TransformFaultType;
class TFMS__TransformJobType;
class TFMS__TransformProfileType;

class TransformFaultException;

namespace TransformMediaService {
    class TransformMediaBinding;
    class TransformMediaStatusBinding;
}
class __AddressType;
class __Alternative;
class __BmContentDescriptionType;
class __ContactDetailsType;
class __Coordinates;
class __Country;
class __CoverageType;
class __Created;
class __DateType;
class __DescriptionType;
class __DetailsType;
class __EntityType;
class __Genre;
class __IdentifierType;
class __Issued;
class __LanguageType;
class __LocationName;
class __Modified;
class __ObjectType;
class __OrganisationDepartment;
class __OrganisationDetailsType;
class __RightsType;
class __Role;
class __Spatial;
class __SubjectType;
class __TargetAudience;
class __Temporal;
class __TextElementType;
class __TitleType;
class __TypeType;

/**
    Whether to return only mandatory elements or all elements.
 */
class BMS__JobInfoSelectionType
{
public:
    enum Type { Mandatory, All };

public:
    BMS__JobInfoSelectionType( const Type &type );
    void setType( Type type );
    BMS__JobInfoSelectionType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__JobInfoSelectionType();
    ~BMS__JobInfoSelectionType();

private:
    Type mType;
};

/**
    Unique identifiers that are based on SMPTE 2029, providing a generic
    representation for UUIDs, ULs and UMIDs.Although empty IDs are permitted,
    these should only be used for initial requests where the server is expected
    to create an identifier.
 */
class BMS__UID
{
public:
    void setValue( const QVariant& val );
    QVariant value() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__UID();
    ~BMS__UID();

private:
    QVariant mValue;
};

/**
    Commands for the control and management of a job. All commands are
    optional.RequiredSupported commands
 */
class BMS__JobCommandType
{
public:
    enum Type { Cancel, Pause, Resume, Restart, Stop, Cleanup, ModifyPriority };

public:
    BMS__JobCommandType( const Type &type );
    void setType( Type type );
    BMS__JobCommandType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__JobCommandType();
    ~BMS__JobCommandType();

private:
    Type mType;
};

/**
    Acceptable priority values used to determine the execution order of jobs.
    See specification Part1 "Job Execution Priority".
 */
class BMS__PriorityType
{
public:
    enum Type { Low, Medium, High, Urgent, Immediate };

public:
    BMS__PriorityType( const Type &type );
    void setType( Type type );
    BMS__PriorityType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__PriorityType();
    ~BMS__PriorityType();

private:
    Type mType;
};

/**
    Commands for the control and management of a queue. All commands are
    optional.RequiredSupported commands
 */
class BMS__QueueCommandType
{
public:
    enum Type { Status, Clear, Stop, Start, Lock, Unlock };

public:
    BMS__QueueCommandType( const Type &type );
    void setType( Type type );
    BMS__QueueCommandType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__QueueCommandType();
    ~BMS__QueueCommandType();

private:
    Type mType;
};

/**
    Current state of a queue.
 */
class BMS__QueueStatusType
{
public:
    enum Type { Started, Stopped, Locked };

public:
    BMS__QueueStatusType( const Type &type );
    void setType( Type type );
    BMS__QueueStatusType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__QueueStatusType();
    ~BMS__QueueStatusType();

private:
    Type mType;
};

/**
    All possible states for a job.
 */
class BMS__JobStatusType
{
public:
    enum Type { Queued, Running, Paused, Completed, Canceled, Stopped, Failed, Cleaned, Unknown };

public:
    BMS__JobStatusType( const Type &type );
    void setType( Type type );
    BMS__JobStatusType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__JobStatusType();
    ~BMS__JobStatusType();

private:
    Type mType;
};

/**
    Specific error codes for the transform service - INF_S02_xxxx:
    Infrastructure errors (system, storage, network, memory, processor) -
    DAT_S02_xxxx: Data errors (validation, missing, duplication) -
    SVC_S02_xxxx: Operation errors (existence, support, lock, connection,
    failure) - SEC_S02_xxxx: Security errors (authentication, authorization)
 */
class TFMS__TransformErrorCodeType
{
public:
    enum Type { SVC_S02_0001 };

public:
    TFMS__TransformErrorCodeType( const Type &type );
    void setType( Type type );
    TFMS__TransformErrorCodeType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    TFMS__TransformErrorCodeType();
    ~TFMS__TransformErrorCodeType();

private:
    Type mType;
};

/**
    This class encapsulates a simple type.
    Whenever you have to pass an object of type
    BMS__PercentageProcessedCompleted you can also pass the value directly as a
    quint64.
 */
class BMS__PercentageProcessedCompleted
{
public:
    void setValue( quint64 value );
    quint64 value() const;
    BMS__PercentageProcessedCompleted( quint64 value );
    operator quint64() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__PercentageProcessedCompleted();
    ~BMS__PercentageProcessedCompleted();

private:
    quint64 mValue;
};

/**
    Common error codes which can be shared by different classes of adapters.
    Error codes are classified in five main categories: • INF_S00_xxxx:
    Infrastructure errors (system, storage, network, memory, processor) •
    DAT_S00_xxxx: Data errors (validation, missing, duplication) •
    SVC_S00_xxxx: Operation errors (existence, support, lock, connection,
    failure) • SEC_S00_xxxx: Security errors (authentication, authorization) •
    EXT_S00_xxxx: Extended code. See extended error code for detail.
 */
class BMS__ErrorCodeType
{
public:
    enum Type { INF_S00_0001, INF_S00_0002, INF_S00_0003, INF_S00_0004, INF_S00_0005, INF_S00_0006, SVC_S00_0001, SVC_S00_0002, SVC_S00_0003, SVC_S00_0004, SVC_S00_0005, SVC_S00_0006, SVC_S00_0007, SVC_S00_0008, SVC_S00_0009, SVC_S00_0010, SVC_S00_0011, SVC_S00_0012, SVC_S00_0013, SVC_S00_0014, SVC_S00_0015, SVC_S00_0016, SVC_S00_0017, SVC_S00_0018, DAT_S00_0001, DAT_S00_0002, DAT_S00_0003, DAT_S00_0004, DAT_S00_0005, DAT_S00_0006, DAT_S00_0007, DAT_S00_0008, DAT_S00_0009, DAT_S00_0010, EXT_S00_0000 };

public:
    BMS__ErrorCodeType( const Type &type );
    void setType( Type type );
    BMS__ErrorCodeType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__ErrorCodeType();
    ~BMS__ErrorCodeType();

private:
    Type mType;
};

/**
    Identification of a specific revision of a resource.
 */
class BMS__RevisionIDType
{
public:
    void setValue( const QString& value );
    QString value() const;
    BMS__RevisionIDType( const QString& value );
    operator QString() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__RevisionIDType();
    ~BMS__RevisionIDType();

private:
    QString mValue;
};

/**
    Audio sample representation: integer or floating point values.
 */
class BMS__AudioSampleType
{
public:
    enum Type { Float, Integer };

public:
    BMS__AudioSampleType( const Type &type );
    void setType( Type type );
    BMS__AudioSampleType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__AudioSampleType();
    ~BMS__AudioSampleType();

private:
    Type mType;
};

/**
    Representation of type of bitrate: constant or variable.
 */
class BMS__BitRateModeType
{
public:
    enum Type { Constant, Variable };

public:
    BMS__BitRateModeType( const Type &type );
    void setType( Type type );
    BMS__BitRateModeType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__BitRateModeType();
    ~BMS__BitRateModeType();

private:
    Type mType;
};

/**
    Scanning format representation: interlaced or progressive.
 */
class BMS__ScanningFormatType
{
public:
    enum Type { Interlaced, Progressive };

public:
    BMS__ScanningFormatType( const Type &type );
    void setType( Type type );
    BMS__ScanningFormatType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__ScanningFormatType();
    ~BMS__ScanningFormatType();

private:
    Type mType;
};

/**
    Different kinds of storage media available (e.g. online on disk).
 */
class BMS__StorageTypes
{
public:
    enum Type { Online, Offline, Hsm, Archive, Playout, Other };

public:
    BMS__StorageTypes( const Type &type );
    void setType( Type type );
    BMS__StorageTypes::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__StorageTypes();
    ~BMS__StorageTypes();

private:
    Type mType;
};

/**
    A representation of AV duration as a SMPTE timecode-like value, with an
    upper bound of 99 hours rather than 23 hours.
 */
class BMS__TimecodeDuration
{
public:
    void setValue( const QString& value );
    QString value() const;
    BMS__TimecodeDuration( const QString& value );
    operator QString() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__TimecodeDuration();
    ~BMS__TimecodeDuration();

private:
    QString mValue;
};

/**
    Scanning order representation: whether the fields are ordered top (upper)
    or bottom (lower) field first.
 */
class BMS__ScanningOrderType
{
public:
    enum Type { Top, Bottom };

public:
    BMS__ScanningOrderType( const Type &type );
    void setType( Type type );
    BMS__ScanningOrderType::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__ScanningOrderType();
    ~BMS__ScanningOrderType();

private:
    Type mType;
};

/**
    Different hash functions that can be used to hash the content, as defined
    in SMPTE ST 2032.
 */
class BMS__HashFunctionTypes
{
public:
    enum Type { CRC32, CRC64, MD5, SHA1, SHA256, SHA384, SHA512 };

public:
    BMS__HashFunctionTypes( const Type &type );
    void setType( Type type );
    BMS__HashFunctionTypes::Type type() const;
    operator Type() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__HashFunctionTypes();
    ~BMS__HashFunctionTypes();

private:
    Type mType;
};

class BMS__ContainerFormat
{
public:
    void setValue( const QString& value );
    QString value() const;
    BMS__ContainerFormat( const QString& value );
    operator QString() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ContainerFormat();
    ~BMS__ContainerFormat();

public:
    BMS__ContainerFormat( const BMS__ContainerFormat& );
    BMS__ContainerFormat &operator=( const BMS__ContainerFormat& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    This is an abstract type to be extended to create types to request status
    of multiple identified jobs or to list the status of jobs that meet
    requirements specified by a filter object.
 */
class BMS__QueryJobRequestType
{
public:
    void setJobInfoSelection( const BMS__JobInfoSelectionType& jobInfoSelection );
    BMS__JobInfoSelectionType jobInfoSelection() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__QueryJobRequestType();
    virtual ~BMS__QueryJobRequestType();
    virtual BMS__QueryJobRequestType *_kd_clone() const;

public:
    BMS__QueryJobRequestType( const BMS__QueryJobRequestType& );
    BMS__QueryJobRequestType &operator=( const BMS__QueryJobRequestType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__DescriptionsType
{
public:
    void setDescription( const QList< BMS__DescriptionType >& description );
    QList< BMS__DescriptionType > description() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__DescriptionsType();
    ~BMS__DescriptionsType();

public:
    BMS__DescriptionsType( const BMS__DescriptionsType& );
    BMS__DescriptionsType &operator=( const BMS__DescriptionsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Provides information on the algorithm used in an integrity check process.
    It is based on the 'hash' type defined in SMPTE ST 2032.
 */
class BMS__HashType
{
public:
    void setHashFunction( const BMS__HashFunctionType& hashFunction );
    BMS__HashFunctionType hashFunction() const;
    void setValue( const QByteArray& value );
    QByteArray value() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__HashType();
    ~BMS__HashType();

public:
    BMS__HashType( const BMS__HashType& );
    BMS__HashType &operator=( const BMS__HashType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Different hash functions that can be used to hash the content, as defined
    in SMPTE ST 2032, in combination with type group description.
 */
class BMS__HashFunctionType
{
public:
    void setValue( const BMS__HashFunctionTypes& value );
    BMS__HashFunctionTypes value() const;
    BMS__HashFunctionType( const BMS__HashFunctionTypes& value );
    operator BMS__HashFunctionTypes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__HashFunctionType();
    ~BMS__HashFunctionType();

public:
    BMS__HashFunctionType( const BMS__HashFunctionType& );
    BMS__HashFunctionType &operator=( const BMS__HashFunctionType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__MimeType
{
public:
    void setValue( const QString& value );
    QString value() const;
    BMS__MimeType( const QString& value );
    operator QString() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__MimeType();
    ~BMS__MimeType();

public:
    BMS__MimeType( const BMS__MimeType& );
    BMS__MimeType &operator=( const BMS__MimeType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Each Type includes an ExtensionGroup to allow for vendor-specific
    extensions, but the definition is out of scope of the FIMS specification.
 */
class BMS__ExtensionGroup
{
public:
    void setAny( const QList< KDSoapValue >& any );
    QList< KDSoapValue > any() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ExtensionGroup();
    ~BMS__ExtensionGroup();

public:
    BMS__ExtensionGroup( const BMS__ExtensionGroup& );
    BMS__ExtensionGroup &operator=( const BMS__ExtensionGroup& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    The source or target of a reference to a distinct resource. Resources
    include queues, jobs, assets, descriptions, formats and profiles.
 */
class BMS__ResourceReferenceType
{
public:
    void setResourceID( const BMS__ResourceIDType& resourceID );
    BMS__ResourceIDType resourceID() const;
    void setRevisionID( const BMS__RevisionIDType& revisionID );
    BMS__RevisionIDType revisionID() const;
    void setLocation( const QString& location );
    QString location() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__ResourceReferenceType();
    virtual ~BMS__ResourceReferenceType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__ResourceReferenceType( const BMS__ResourceReferenceType& );
    BMS__ResourceReferenceType &operator=( const BMS__ResourceReferenceType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__BMContentFormatsType
{
public:
    void setBmContentFormat( const QList< BMS__BMContentFormatType >& bmContentFormat );
    QList< BMS__BMContentFormatType > bmContentFormat() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__BMContentFormatsType();
    ~BMS__BMContentFormatsType();

public:
    BMS__BMContentFormatsType( const BMS__BMContentFormatsType& );
    BMS__BMContentFormatsType &operator=( const BMS__BMContentFormatsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Parameters specific to transfer media services that can be re-used for
    other services. Note: Some parameters might be added to the atom in future
    version to specify network resource utilization, a list of acceptable
    transfer mechanisms or additional security options including whether the
    received files should be checked against a fingerprint and whether they are
    encrypted.
 */
class BMS__TransferAtomType
{
public:
    void setDestination( const QString& destination );
    QString destination() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__TransferAtomType();
    ~BMS__TransferAtomType();

public:
    BMS__TransferAtomType( const BMS__TransferAtomType& );
    BMS__TransferAtomType &operator=( const BMS__TransferAtomType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Represents the acknowledgment sent back from the transform media service
    when the transform job is submitted.
 */

class TFMS__TransformResponseType
{
public:

    void setTransformJob( const TFMS__TransformJobType& transformJob );
    TFMS__TransformJobType transformJob() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    TFMS__TransformResponseType();
    ~TFMS__TransformResponseType();

public:
    TFMS__TransformResponseType( const TFMS__TransformResponseType& );
    TFMS__TransformResponseType &operator=( const TFMS__TransformResponseType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Describes a captioning format and its purpose.
 */
class BMS__CaptioningFormatType
{
public:
    void setValue( const QString& value );
    QString value() const;
    BMS__CaptioningFormatType( const QString& value );
    operator QString() const;
    void setCaptioningSourceUri( const QString& captioningSourceUri );
    QString captioningSourceUri() const;
    void setLanguage( const QString& language );
    QString language() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__CaptioningFormatType();
    ~BMS__CaptioningFormatType();

public:
    BMS__CaptioningFormatType( const BMS__CaptioningFormatType& );
    BMS__CaptioningFormatType &operator=( const BMS__CaptioningFormatType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    This type provides a response to QueryJobRequestType. It contains a list of
    queryJobInfo elements. Furthermore, the response message provided by this
    type supports a polling interaction pattern for retrieving the status and
    the response of an asynchronous job request.
 */
class BMS__QueryJobResponseType
{
public:
    void setJobs( const BMS__JobsType& jobs );
    BMS__JobsType jobs() const;
    void setNotReportedResultsNumber( quint64 notReportedResultsNumber );
    quint64 notReportedResultsNumber() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__QueryJobResponseType();
    ~BMS__QueryJobResponseType();

public:
    BMS__QueryJobResponseType( const BMS__QueryJobResponseType& );
    BMS__QueryJobResponseType &operator=( const BMS__QueryJobResponseType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__TrackConfiguration
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__TrackConfiguration();
    ~BMS__TrackConfiguration();

};

class __LanguageType
{
public:
    void setLang( const QString& lang );
    QString lang() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __LanguageType();
    ~__LanguageType();

public:
    __LanguageType( const __LanguageType& );
    __LanguageType &operator=( const __LanguageType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __Coordinates
{
public:
    void setPosy( float posy );
    float posy() const;
    void setPosx( float posx );
    float posx() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Coordinates();
    ~__Coordinates();

public:
    __Coordinates( const __Coordinates& );
    __Coordinates &operator=( const __Coordinates& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Measure of the duration of an operation or item of content.One of the
    elements shall be used.RequiredElement(s) supported.
 */
class BMS__DurationType
{
public:
    void setTimecode( const BMS__TimecodeDuration& timecode );
    BMS__TimecodeDuration timecode() const;
    void setNormalPlayTime( const QString& normalPlayTime );
    QString normalPlayTime() const;
    void setEditUnitNumber( const BMS__EditUnitNumberType& editUnitNumber );
    BMS__EditUnitNumberType editUnitNumber() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__DurationType();
    ~BMS__DurationType();

public:
    BMS__DurationType( const BMS__DurationType& );
    BMS__DurationType &operator=( const BMS__DurationType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__ServiceDescription
{
public:
    void setAny( const QList< KDSoapValue >& any );
    QList< KDSoapValue > any() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ServiceDescription();
    ~BMS__ServiceDescription();

public:
    BMS__ServiceDescription( const BMS__ServiceDescription& );
    BMS__ServiceDescription &operator=( const BMS__ServiceDescription& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    A number of edit units as defined in EBU Tech 3293. An editUnit is the
    inverse of the edit rate, or corrected edit rate as the result of
    editUnit=1/(editrate*(factorNumerator/factorDenominator)). A number of edit
    units as defined in EBU Tech 3293. An editUnit is the inverse of the edit
    rate, or corrected edit rate as the result of
    editUnit=1/(editRrate*(factorNumerator/factorDenominator)). Values of the
    combination of editRate, factorNumerator, and factorDenominator shall be
    subject to the constraints listed in the Annex EditUnitNumberType. See EBU
    Tech 3293 for more information.
 */
class BMS__EditUnitNumberType
{
public:
    void setValue( qint64 value );
    qint64 value() const;
    BMS__EditUnitNumberType( qint64 value );
    operator qint64() const;
    void setEditRate( quint64 editRate );
    quint64 editRate() const;
    void setFactorNumerator( quint64 factorNumerator );
    quint64 factorNumerator() const;
    void setFactorDenominator( quint64 factorDenominator );
    quint64 factorDenominator() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__EditUnitNumberType();
    ~BMS__EditUnitNumberType();

public:
    BMS__EditUnitNumberType( const BMS__EditUnitNumberType& );
    BMS__EditUnitNumberType &operator=( const BMS__EditUnitNumberType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __ContactDetailsType
{
public:
    void setName( const QString& name );
    QString name() const;
    void setGivenName( const QString& givenName );
    QString givenName() const;
    void setFamilyName( const QString& familyName );
    QString familyName() const;
    void setOtherGivenName( const QStringList& otherGivenName );
    QStringList otherGivenName() const;
    void setSuffix( const QString& suffix );
    QString suffix() const;
    void setSalutation( const QString& salutation );
    QString salutation() const;
    void setUsername( const QList< __TextElementType >& username );
    QList< __TextElementType > username() const;
    void setOccupation( const __TextElementType& occupation );
    __TextElementType occupation() const;
    void setDetails( const QList< __DetailsType >& details );
    QList< __DetailsType > details() const;
    void setStageName( const QList< __TextElementType >& stageName );
    QList< __TextElementType > stageName() const;
    void setRelatedContacts( const QList< __EntityType >& relatedContacts );
    QList< __EntityType > relatedContacts() const;
    void setContactId( const QString& contactId );
    QString contactId() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __ContactDetailsType();
    ~__ContactDetailsType();

public:
    __ContactDetailsType( const __ContactDetailsType& );
    __ContactDetailsType &operator=( const __ContactDetailsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __Spatial
{
public:
    void setLocationName( const __LocationName& locationName );
    __LocationName locationName() const;
    void setCoordinates( const __Coordinates& coordinates );
    __Coordinates coordinates() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Spatial();
    ~__Spatial();

public:
    __Spatial( const __Spatial& );
    __Spatial &operator=( const __Spatial& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    A request to the transform media service to transform content from a source
    format to a target format.
 */
class TFMS__TransformRequestType
{
public:
    void setTransformJob( const TFMS__TransformJobType& transformJob );
    TFMS__TransformJobType transformJob() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    TFMS__TransformRequestType();
    ~TFMS__TransformRequestType();

public:
    TFMS__TransformRequestType( const TFMS__TransformRequestType& );
    TFMS__TransformRequestType &operator=( const TFMS__TransformRequestType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    This type represents a response to a queue management request. It provides
    information such as the status and the length of queue.
 */
class BMS__ManageQueueResponseType
{
public:
    void setQueue( const BMS__QueueType& queue );
    BMS__QueueType queue() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ManageQueueResponseType();
    ~BMS__ManageQueueResponseType();

public:
    BMS__ManageQueueResponseType( const BMS__ManageQueueResponseType& );
    BMS__ManageQueueResponseType &operator=( const BMS__ManageQueueResponseType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__BMContentsType
{
public:
    void setBmContent( const QList< BMS__BMContentType >& bmContent );
    QList< BMS__BMContentType > bmContent() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__BMContentsType();
    ~BMS__BMContentsType();

public:
    BMS__BMContentsType( const BMS__BMContentsType& );
    BMS__BMContentsType &operator=( const BMS__BMContentsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __BmContentDescriptionType
{
public:
    void setTitle( const QList< __TextElementType >& title );
    QList< __TextElementType > title() const;
    void setAlternativeTitle( const QList< __TitleType >& alternativeTitle );
    QList< __TitleType > alternativeTitle() const;
    void setCreator( const QList< __EntityType >& creator );
    QList< __EntityType > creator() const;
    void setSubject( const QList< __SubjectType >& subject );
    QList< __SubjectType > subject() const;
    void setDescription( const QList< __DescriptionType >& description );
    QList< __DescriptionType > description() const;
    void setPublisher( const QList< __EntityType >& publisher );
    QList< __EntityType > publisher() const;
    void setContributor( const QList< __EntityType >& contributor );
    QList< __EntityType > contributor() const;
    void setDate( const QList< __DateType >& date );
    QList< __DateType > date() const;
    void setType( const QList< __TypeType >& type );
    QList< __TypeType > type() const;
    void setIdentifier( const QList< __IdentifierType >& identifier );
    QList< __IdentifierType > identifier() const;
    void setLanguage( const QList< __LanguageType >& language );
    QList< __LanguageType > language() const;
    void setCoverage( const QList< __CoverageType >& coverage );
    QList< __CoverageType > coverage() const;
    void setRights( const QList< __RightsType >& rights );
    QList< __RightsType > rights() const;
    void setVersion( const QString& version );
    QString version() const;
    void setLang( const QString& lang );
    QString lang() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __BmContentDescriptionType();
    ~__BmContentDescriptionType();

public:
    __BmContentDescriptionType( const __BmContentDescriptionType& );
    __BmContentDescriptionType &operator=( const __BmContentDescriptionType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    A length value and its unit of measurement.
 */
class BMS__LengthType
{
public:
    void setValue( quint64 value );
    quint64 value() const;
    BMS__LengthType( quint64 value );
    operator quint64() const;
    void setUnit( const QString& unit );
    QString unit() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__LengthType();
    ~BMS__LengthType();

public:
    BMS__LengthType( const BMS__LengthType& );
    BMS__LengthType &operator=( const BMS__LengthType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__FormatCollection
{
public:
    void setVideoFormat( const BMS__VideoFormatType& videoFormat );
    BMS__VideoFormatType videoFormat() const;
    void setAudioFormat( const BMS__AudioFormatType& audioFormat );
    BMS__AudioFormatType audioFormat() const;
    void setDataFormat( const BMS__DataFormatType& dataFormat );
    BMS__DataFormatType dataFormat() const;
    void setContainerFormat( const BMS__ContainerFormatType& containerFormat );
    BMS__ContainerFormatType containerFormat() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__FormatCollection();
    ~BMS__FormatCollection();

public:
    BMS__FormatCollection( const BMS__FormatCollection& );
    BMS__FormatCollection &operator=( const BMS__FormatCollection& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    A rational value expressed by its fraction of a second numerator and
    denominator components. Rational values can be used to represent edit
    rates. For example, a frame rate of 29.97 would be represented as 30
    corrected by 1000 (numerator) / 1001 (denominator).
 */
class BMS__RationalType
{
public:
    void setValue( qint64 value );
    qint64 value() const;
    BMS__RationalType( qint64 value );
    operator qint64() const;
    void setNumerator( quint64 numerator );
    quint64 numerator() const;
    void setDenominator( quint64 denominator );
    quint64 denominator() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__RationalType();
    ~BMS__RationalType();

public:
    BMS__RationalType( const BMS__RationalType& );
    BMS__RationalType &operator=( const BMS__RationalType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Each Type includes an ExtensionAttributes to allow for vendor-specific
    extensions, but the definition is out of scope of the FIMS specification.
 */
class BMS__ExtensionAttributes
{
public:
    void setAnyAttribute( const KDSoapValue& anyAttribute );
    KDSoapValue anyAttribute() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ExtensionAttributes();
    ~BMS__ExtensionAttributes();

public:
    BMS__ExtensionAttributes( const BMS__ExtensionAttributes& );
    BMS__ExtensionAttributes &operator=( const BMS__ExtensionAttributes& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __DateType
{
public:
    void setCreated( const __Created& created );
    __Created created() const;
    void setModified( const __Modified& modified );
    __Modified modified() const;
    void setIssued( const __Issued& issued );
    __Issued issued() const;
    void setAlternative( const __Alternative& alternative );
    __Alternative alternative() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __DateType();
    ~__DateType();

public:
    __DateType( const __DateType& );
    __DateType &operator=( const __DateType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Notification of the successful completion of a transform job.If one or more
    "notifyAt" elements are set for the associated transform job, then the
    service shall respond with a notification to the specified endpoints when
    the job completes. (If notification is supported.)
 */
class TFMS__TransformNotificationType
{
public:
    void setTransformJob( const TFMS__TransformJobType& transformJob );
    TFMS__TransformJobType transformJob() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    TFMS__TransformNotificationType();
    ~TFMS__TransformNotificationType();

public:
    TFMS__TransformNotificationType( const TFMS__TransformNotificationType& );
    TFMS__TransformNotificationType &operator=( const TFMS__TransformNotificationType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __EntityType
{
public:
    void setContactDetails( const QList< __ContactDetailsType >& contactDetails );
    QList< __ContactDetailsType > contactDetails() const;
    void setOrganisationDetails( const QList< __OrganisationDetailsType >& organisationDetails );
    QList< __OrganisationDetailsType > organisationDetails() const;
    void setRole( const QList< __Role >& role );
    QList< __Role > role() const;
    void setEntityId( const QString& entityId );
    QString entityId() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __EntityType();
    ~__EntityType();

public:
    __EntityType( const __EntityType& );
    __EntityType &operator=( const __EntityType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __Issued
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Issued();
    ~__Issued();

};

/**
    Tracks expose the underlying structural metadata of the content streams
    embedded inside a physical content essence. Examples of tracks are the
    separate audio and video streams inside an audiovisual content essence.
    Tracks have a category, for example "main" (videoTrack), "audioDescription"
    (audioTrack), "closed captioning" (dataTrack). Tracks have also an
    identifier and a description.
 */
class BMS__BMTrackType
{
public:
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    void setTrackID( const BMS__UID& trackID );
    BMS__UID trackID() const;
    void setTrackName( const QString& trackName );
    QString trackName() const;
    void setLanguage( const QString& language );
    QString language() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__BMTrackType();
    ~BMS__BMTrackType();

public:
    BMS__BMTrackType( const BMS__BMTrackType& );
    BMS__BMTrackType &operator=( const BMS__BMTrackType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__JobsType
{
public:
    void setJob( const QList< BMS__JobType >& job );
    QList< BMS__JobType > job() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__JobsType();
    ~BMS__JobsType();

public:
    BMS__JobsType( const BMS__JobsType& );
    BMS__JobsType &operator=( const BMS__JobsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Additional description of the lower-level errors.
 */
class BMS__InnerFaultType
{
public:
    void setCode( const QString& code );
    QString code() const;
    void setDescription( const QString& description );
    QString description() const;
    void setDetail( const QString& detail );
    QString detail() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__InnerFaultType();
    ~BMS__InnerFaultType();

public:
    BMS__InnerFaultType( const BMS__InnerFaultType& );
    BMS__InnerFaultType &operator=( const BMS__InnerFaultType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__BMObjectsType
{
public:
    void setBmObject( const QList< BMS__BMObjectType >& bmObject );
    QList< BMS__BMObjectType > bmObject() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__BMObjectsType();
    ~BMS__BMObjectsType();

public:
    BMS__BMObjectsType( const BMS__BMObjectsType& );
    BMS__BMObjectsType &operator=( const BMS__BMObjectsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    FIMS service common mechanism to manage jobs and update jobs properties,
    including job priority. The manage job request uses the jobCommand to set
    the intent of the command (acting on the job state).
 */
class BMS__ManageJobRequestType
{
public:
    void setJobID( const BMS__UID& jobID );
    BMS__UID jobID() const;
    void setJobCommand( const BMS__JobCommandType& jobCommand );
    BMS__JobCommandType jobCommand() const;
    void setPriority( const BMS__PriorityType& priority );
    BMS__PriorityType priority() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ManageJobRequestType();
    ~BMS__ManageJobRequestType();

public:
    BMS__ManageJobRequestType( const BMS__ManageJobRequestType& );
    BMS__ManageJobRequestType &operator=( const BMS__ManageJobRequestType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __TypeType
{
public:
    void setGenre( const QList< __Genre >& genre );
    QList< __Genre > genre() const;
    void setObjectType( const QList< __ObjectType >& objectType );
    QList< __ObjectType > objectType() const;
    void setTargetAudience( const QList< __TargetAudience >& targetAudience );
    QList< __TargetAudience > targetAudience() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __TypeType();
    ~__TypeType();

public:
    __TypeType( const __TypeType& );
    __TypeType &operator=( const __TypeType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Ancillary data packet type. See SMPTE ST 291 and SMPTE ST 436.
 */
class BMS__AncillaryDataFormatType
{
public:
    void setDID( qint64 dID );
    qint64 dID() const;
    void setSDID( qint64 sDID );
    qint64 sDID() const;
    void setLineNumber( qint64 lineNumber );
    qint64 lineNumber() const;
    void setWrappingType( qint64 wrappingType );
    qint64 wrappingType() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__AncillaryDataFormatType();
    ~BMS__AncillaryDataFormatType();

public:
    BMS__AncillaryDataFormatType( const BMS__AncillaryDataFormatType& );
    BMS__AncillaryDataFormatType &operator=( const BMS__AncillaryDataFormatType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __Alternative
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Alternative();
    ~__Alternative();

};

class __Role
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Role();
    ~__Role();

};

class __Country
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Country();
    ~__Country();

};

class __RightsType
{
public:
    void setRightsExpression( const QList< __TextElementType >& rightsExpression );
    QList< __TextElementType > rightsExpression() const;
    void setRightsLink( const QString& rightsLink );
    QString rightsLink() const;
    void setRightsHolder( const __EntityType& rightsHolder );
    __EntityType rightsHolder() const;
    void setExploitationIssues( const __TextElementType& exploitationIssues );
    __TextElementType exploitationIssues() const;
    void setCoverage( const __CoverageType& coverage );
    __CoverageType coverage() const;
    void setRightsClearanceFlag( bool rightsClearanceFlag );
    bool rightsClearanceFlag() const;
    void setDisclaimer( const QList< __TextElementType >& disclaimer );
    QList< __TextElementType > disclaimer() const;
    void setRightsId( const QList< __IdentifierType >& rightsId );
    QList< __IdentifierType > rightsId() const;
    void setContactDetails( const QList< __ContactDetailsType >& contactDetails );
    QList< __ContactDetailsType > contactDetails() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __RightsType();
    ~__RightsType();

public:
    __RightsType( const __RightsType& );
    __RightsType &operator=( const __RightsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Kinds of time when a job is required to start.One of the following types
    shall be used. StartJobByNoWaitType shall be supported.RequiredSupported
    start job types
 */
class BMS__StartJobType
{
public:
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__StartJobType();
    virtual ~BMS__StartJobType();
    virtual BMS__StartJobType *_kd_clone() const;

};

/**
    Statistics on the amount of information processed so far. For example in
    terms of bytes or frames processed.RequiredThe type of processed
    information provided.
 */
class BMS__ProcessedInfoType
{
public:
    void setPercentageProcessedCompleted( const BMS__PercentageProcessedCompleted& percentageProcessedCompleted );
    BMS__PercentageProcessedCompleted percentageProcessedCompleted() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__ProcessedInfoType();
    virtual ~BMS__ProcessedInfoType();
    virtual BMS__ProcessedInfoType *_kd_clone() const;

public:
    BMS__ProcessedInfoType( const BMS__ProcessedInfoType& );
    BMS__ProcessedInfoType &operator=( const BMS__ProcessedInfoType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Specifies a list of jobs to be retrieved. The list includes only jobs that
    fall in the period of time specified (if provided) and in the specified
    category (queued, active, completed, failed).
 */
class BMS__ListFilterType
{
public:
    void setFromDate( const KDDateTime& fromDate );
    KDDateTime fromDate() const;
    void setToDate( const KDDateTime& toDate );
    KDDateTime toDate() const;
    void setIncludeQueued( bool includeQueued );
    bool includeQueued() const;
    void setIncludeActive( bool includeActive );
    bool includeActive() const;
    void setIncludeFinished( bool includeFinished );
    bool includeFinished() const;
    void setIncludeFailed( bool includeFailed );
    bool includeFailed() const;
    void setMaxNumberResults( quint64 maxNumberResults );
    quint64 maxNumberResults() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ListFilterType();
    ~BMS__ListFilterType();

public:
    BMS__ListFilterType( const BMS__ListFilterType& );
    BMS__ListFilterType &operator=( const BMS__ListFilterType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    This type provides a mechanism to manage a queue, for example checking the
    status of the queue, stopping and starting the queue and locking the queue.
    The queue management request uses the queueCommand to set the intent of the
    command (requesting status or acting on the queue state).
 */
class BMS__ManageQueueRequestType
{
public:
    void setQueueID( const BMS__UID& queueID );
    BMS__UID queueID() const;
    void setQueueCommand( const BMS__QueueCommandType& queueCommand );
    BMS__QueueCommandType queueCommand() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ManageQueueRequestType();
    ~BMS__ManageQueueRequestType();

public:
    BMS__ManageQueueRequestType( const BMS__ManageQueueRequestType& );
    BMS__ManageQueueRequestType &operator=( const BMS__ManageQueueRequestType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __IdentifierType
{
public:
    void setValue( const QString& value );
    QString value() const;
    __IdentifierType( const QString& value );
    operator QString() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __IdentifierType();
    ~__IdentifierType();

public:
    __IdentifierType( const __IdentifierType& );
    __IdentifierType &operator=( const __IdentifierType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Provides address details for an organisation
 */
class __AddressType
{
public:
    void setAddressLine( const QList< __TextElementType >& addressLine );
    QList< __TextElementType > addressLine() const;
    void setAddressTownCity( const __TextElementType& addressTownCity );
    __TextElementType addressTownCity() const;
    void setAddressCountyState( const __TextElementType& addressCountyState );
    __TextElementType addressCountyState() const;
    void setAddressDeliveryCode( const QString& addressDeliveryCode );
    QString addressDeliveryCode() const;
    void setCountry( const __Country& country );
    __Country country() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __AddressType();
    ~__AddressType();

public:
    __AddressType( const __AddressType& );
    __AddressType &operator=( const __AddressType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Details of a fault. This type can be extended by each service to provide
    additional error codes.
 */
class BMS__FaultType
{
public:
    void setCode( const BMS__ErrorCodeType& code );
    BMS__ErrorCodeType code() const;
    void setDescription( const QString& description );
    QString description() const;
    void setDetail( const QString& detail );
    QString detail() const;
    void setInnerFault( const QList< BMS__InnerFaultType >& innerFault );
    QList< BMS__InnerFaultType > innerFault() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__FaultType();
    virtual ~BMS__FaultType();
    virtual BMS__FaultType *_kd_clone() const;

public:
    BMS__FaultType( const BMS__FaultType& );
    BMS__FaultType &operator=( const BMS__FaultType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __Modified
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Modified();
    ~__Modified();

};

/**
    Describes a codec used for video or audio encoding.
 */
class BMS__CodecType
{
public:
    void setName( const QString& name );
    QString name() const;
    void setVendor( const QString& vendor );
    QString vendor() const;
    void setVersion( const QString& version );
    QString version() const;
    void setFamily( const QString& family );
    QString family() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__CodecType();
    ~BMS__CodecType();

public:
    BMS__CodecType( const BMS__CodecType& );
    BMS__CodecType &operator=( const BMS__CodecType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Fault notification for the transform service, including the related capture
    job and the fault code.If one or more "notifyAt" elements are set for the
    transform job and a failure occurs during the job execution, then the
    service shall respond with a transform fault notification to the endpoint
    specified by 'faultTo'.
 */
class TFMS__TransformFaultNotificationType
{
public:
    void setTransformJob( const TFMS__TransformJobType& transformJob );
    TFMS__TransformJobType transformJob() const;
    void setFault( const TFMS__TransformFaultType& fault );
    TFMS__TransformFaultType fault() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    TFMS__TransformFaultNotificationType();
    ~TFMS__TransformFaultNotificationType();

public:
    TFMS__TransformFaultNotificationType( const TFMS__TransformFaultNotificationType& );
    TFMS__TransformFaultNotificationType &operator=( const TFMS__TransformFaultNotificationType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__ContainerMimeType
{
public:
    void setValue( const QString& value );
    QString value() const;
    BMS__ContainerMimeType( const QString& value );
    operator QString() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ContainerMimeType();
    ~BMS__ContainerMimeType();

public:
    BMS__ContainerMimeType( const BMS__ContainerMimeType& );
    BMS__ContainerMimeType &operator=( const BMS__ContainerMimeType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    This type provides job status as a response to a job management request
    (e.g. pausing a job).
 */
class BMS__ManageJobResponseType
{
public:
    void setJob( const BMS__JobType& job );
    BMS__JobType job() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ManageJobResponseType();
    ~BMS__ManageJobResponseType();

public:
    BMS__ManageJobResponseType( const BMS__ManageJobResponseType& );
    BMS__ManageJobResponseType &operator=( const BMS__ManageJobResponseType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class BMS__BMEssenceLocatorsType
{
public:
    void setBmEssenceLocator( const QList< BMS__BMEssenceLocatorType >& bmEssenceLocator );
    QList< BMS__BMEssenceLocatorType > bmEssenceLocator() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__BMEssenceLocatorsType();
    ~BMS__BMEssenceLocatorsType();

public:
    BMS__BMEssenceLocatorsType( const BMS__BMEssenceLocatorsType& );
    BMS__BMEssenceLocatorsType &operator=( const BMS__BMEssenceLocatorsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Allows users / implementers to define their own technical parameters as
    ‘string’ for which a format can be defined to restrict the string format.
    See 'TechnicalAttributeString' in EBU Tech 3293 for more information.
 */
class BMS__TechnicalAttributeType
{
public:
    void setValue( const QString& value );
    QString value() const;
    BMS__TechnicalAttributeType( const QString& value );
    operator QString() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__TechnicalAttributeType();
    ~BMS__TechnicalAttributeType();

public:
    BMS__TechnicalAttributeType( const BMS__TechnicalAttributeType& );
    BMS__TechnicalAttributeType &operator=( const BMS__TechnicalAttributeType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Parameters specific to the transform media service that can be re-used by
    other services. Note: Some parameters might be added to this type in future
    version of this specification to specify AV Process, etc.
 */
class BMS__TransformAtomType
{
public:
    void setVideoFormat( const BMS__VideoFormatType& videoFormat );
    BMS__VideoFormatType videoFormat() const;
    void setAudioFormat( const BMS__AudioFormatType& audioFormat );
    BMS__AudioFormatType audioFormat() const;
    void setContainerFormat( const BMS__ContainerFormatType& containerFormat );
    BMS__ContainerFormatType containerFormat() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__TransformAtomType();
    ~BMS__TransformAtomType();

public:
    BMS__TransformAtomType( const BMS__TransformAtomType& );
    BMS__TransformAtomType &operator=( const BMS__TransformAtomType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class TFMS__Profiles
{
public:
    void setTransformProfile( const QList< TFMS__TransformProfileType >& transformProfile );
    QList< TFMS__TransformProfileType > transformProfile() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    TFMS__Profiles();
    ~TFMS__Profiles();

public:
    TFMS__Profiles( const TFMS__Profiles& );
    TFMS__Profiles &operator=( const TFMS__Profiles& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Different kinds of storage media available (e.g. online on disk), in
    combination with type group attributes.
 */
class BMS__StorageType
{
public:
    void setValue( const BMS__StorageTypes& value );
    BMS__StorageTypes value() const;
    BMS__StorageType( const BMS__StorageTypes& value );
    operator BMS__StorageTypes() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__StorageType();
    ~BMS__StorageType();

public:
    BMS__StorageType( const BMS__StorageType& );
    BMS__StorageType &operator=( const BMS__StorageType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __DetailsType
{
public:
    void setEmailAddress( const QStringList& emailAddress );
    QStringList emailAddress() const;
    void setWebAddress( const QString& webAddress );
    QString webAddress() const;
    void setAddress( const __AddressType& address );
    __AddressType address() const;
    void setTelephoneNumber( const QString& telephoneNumber );
    QString telephoneNumber() const;
    void setMobileTelephoneNumber( const QString& mobileTelephoneNumber );
    QString mobileTelephoneNumber() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __DetailsType();
    ~__DetailsType();

public:
    __DetailsType( const __DetailsType& );
    __DetailsType &operator=( const __DetailsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __TextElementType
{
public:
    void setValue( const QString& value );
    QString value() const;
    __TextElementType( const QString& value );
    operator QString() const;
    void setLang( const QString& lang );
    QString lang() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    __TextElementType();
    virtual ~__TextElementType();

public:
    __TextElementType( const __TextElementType& );
    __TextElementType &operator=( const __TextElementType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Provides endpoints where a service can send back a notification for a job
    completed or failed.
 */
class BMS__AsyncEndpointType
{
public:
    void setReplyTo( const QString& replyTo );
    QString replyTo() const;
    void setFaultTo( const QString& faultTo );
    QString faultTo() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__AsyncEndpointType();
    ~BMS__AsyncEndpointType();

public:
    BMS__AsyncEndpointType( const BMS__AsyncEndpointType& );
    BMS__AsyncEndpointType &operator=( const BMS__AsyncEndpointType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __Created
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Created();
    ~__Created();

};

class __CoverageType
{
public:
    void setTemporal( const __Temporal& temporal );
    __Temporal temporal() const;
    void setSpatial( const __Spatial& spatial );
    __Spatial spatial() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __CoverageType();
    ~__CoverageType();

public:
    __CoverageType( const __CoverageType& );
    __CoverageType &operator=( const __CoverageType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __OrganisationDetailsType
{
public:
    void setOrganisationName( const QList< __TextElementType >& organisationName );
    QList< __TextElementType > organisationName() const;
    void setOrganisationCode( const QStringList& organisationCode );
    QStringList organisationCode() const;
    void setOrganisationDepartment( const __OrganisationDepartment& organisationDepartment );
    __OrganisationDepartment organisationDepartment() const;
    void setDetails( const QList< __DetailsType >& details );
    QList< __DetailsType > details() const;
    void setContacts( const QList< __EntityType >& contacts );
    QList< __EntityType > contacts() const;
    void setOrganisationId( const QString& organisationId );
    QString organisationId() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __OrganisationDetailsType();
    ~__OrganisationDetailsType();

public:
    __OrganisationDetailsType( const __OrganisationDetailsType& );
    __OrganisationDetailsType &operator=( const __OrganisationDetailsType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class TransformMediaBindingServerBase : public QObject, public KDSoapServerObjectInterface
{
    Q_OBJECT

    Q_INTERFACES(KDSoapServerObjectInterface)

public:
    void transformResponse( const KDSoapDelayedResponseHandle& responseHandle, const TFMS__TransformResponseType& ret );
    virtual TFMS__TransformResponseType transform( const TFMS__TransformRequestType& in ) = 0;
    void processRequest( const KDSoapMessage &request, KDSoapMessage &response, const QByteArray& soapAction );

};

class TransformMediaStatusBindingServerBase : public QObject, public KDSoapServerObjectInterface
{
    Q_OBJECT

    Q_INTERFACES(KDSoapServerObjectInterface)

public:
    void manageJobResponse( const KDSoapDelayedResponseHandle& responseHandle, const BMS__ManageJobResponseType& ret );
    virtual BMS__ManageJobResponseType manageJob( const BMS__ManageJobRequestType& in ) = 0;
    void manageQueueResponse( const KDSoapDelayedResponseHandle& responseHandle, const BMS__ManageQueueResponseType& ret );
    virtual BMS__ManageQueueResponseType manageQueue( const BMS__ManageQueueRequestType& in ) = 0;
    void queryJobResponse( const KDSoapDelayedResponseHandle& responseHandle, const BMS__QueryJobResponseType& ret );
    virtual BMS__QueryJobResponseType queryJob( const BMS__QueryJobRequestType& in ) = 0;
    void processRequest( const KDSoapMessage &request, KDSoapMessage &response, const QByteArray& soapAction );

};

class TransformMediaNotificationServiceServerBase : public QObject, public KDSoapServerObjectInterface
{
    Q_OBJECT

    Q_INTERFACES(KDSoapServerObjectInterface)

public:
    virtual void notifyTransformResult( const TFMS__TransformNotificationType& in ) = 0;
    virtual void notifyFault( const TFMS__TransformFaultNotificationType& fault ) = 0;
    void processRequest( const KDSoapMessage &request, KDSoapMessage &response, const QByteArray& soapAction );

};

/**
    This type provides a unique way to identify a resource.
 */
class BMS__ResourceIDType
{
public:
    void setValue( const BMS__UID& value );
    BMS__UID value() const;
    BMS__ResourceIDType( const BMS__UID& value );
    operator BMS__UID() const;
    QVariant serialize() const;
    void deserialize( const QVariant& value );
    BMS__ResourceIDType();
    ~BMS__ResourceIDType();

private:
    BMS__UID mValue;
};

/**
    Statistics on number of bytes processed.
 */
class BMS__ProcessedInfoByBytesType : public BMS__ProcessedInfoType
{
public:
    void setProcessedBytesCount( quint64 processedBytesCount );
    quint64 processedBytesCount() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ProcessedInfoByBytesType();
    ~BMS__ProcessedInfoByBytesType();
    virtual BMS__ProcessedInfoType *_kd_clone() const;

public:
    BMS__ProcessedInfoByBytesType( const BMS__ProcessedInfoByBytesType& );
    BMS__ProcessedInfoByBytesType &operator=( const BMS__ProcessedInfoByBytesType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __LocationName : public __TextElementType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __LocationName();
    ~__LocationName();

};

/**
    This type is part of the FIMS service common status interface and provides
    a mechanism query jobs and retrieve information associated to them. A
    client can request the status of multiple identified jobs.
 */
class BMS__QueryJobRequestByIDType : public BMS__QueryJobRequestType
{
public:
    void setJobID( const QList< BMS__UID >& jobID );
    QList< BMS__UID > jobID() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__QueryJobRequestByIDType();
    ~BMS__QueryJobRequestByIDType();
    virtual BMS__QueryJobRequestType *_kd_clone() const;

public:
    BMS__QueryJobRequestByIDType( const BMS__QueryJobRequestByIDType& );
    BMS__QueryJobRequestByIDType &operator=( const BMS__QueryJobRequestByIDType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __OrganisationDepartment : public __TextElementType
{
public:
    void setDepartmentId( const QString& departmentId );
    QString departmentId() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __OrganisationDepartment();
    ~__OrganisationDepartment();

public:
    __OrganisationDepartment( const __OrganisationDepartment& );
    __OrganisationDepartment &operator=( const __OrganisationDepartment& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Start the job as close as possible to the defined start process time.
 */
class BMS__StartJobByLatestType : public BMS__StartJobType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__StartJobByLatestType();
    ~BMS__StartJobByLatestType();
    virtual BMS__StartJobType *_kd_clone() const;

};

class __Genre : public __TextElementType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Genre();
    ~__Genre();

};

/**
    Resources include queues, jobs, assets, descriptions, formats and profiles.
 */
class BMS__ResourceType : public BMS__ResourceReferenceType
{
public:
    void setResourceCreationDate( const KDDateTime& resourceCreationDate );
    KDDateTime resourceCreationDate() const;
    void setResourceModifiedDate( const KDDateTime& resourceModifiedDate );
    KDDateTime resourceModifiedDate() const;
    void setNotifyAt( const BMS__AsyncEndpointType& notifyAt );
    BMS__AsyncEndpointType notifyAt() const;
    void setExtensionGroup( const BMS__ExtensionGroup& extensionGroup );
    BMS__ExtensionGroup extensionGroup() const;
    void setExtensionAttributes( const BMS__ExtensionAttributes& extensionAttributes );
    BMS__ExtensionAttributes extensionAttributes() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__ResourceType();
    virtual ~BMS__ResourceType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__ResourceType( const BMS__ResourceType& );
    BMS__ResourceType &operator=( const BMS__ResourceType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Common representation of the content exchanged by FIMS media services,
    through reference to logical content objects. Note that although the
    current BMObject can only reference at most one logical content item, it is
    intended that future versions of FIMS will extend BMObject to provide
    different kinds of content collections, such as sequences and edit decision
    lists.
 */
class BMS__BMObjectType : public BMS__ResourceType
{
public:
    void setBmContents( const BMS__BMContentsType& bmContents );
    BMS__BMContentsType bmContents() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__BMObjectType();
    ~BMS__BMObjectType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__BMObjectType( const BMS__BMObjectType& );
    BMS__BMObjectType &operator=( const BMS__BMObjectType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Provides a time when the job should start.
 */
class BMS__StartJobByTimeType : public BMS__StartJobType
{
public:
    void setTime( const KDDateTime& time );
    KDDateTime time() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__StartJobByTimeType();
    ~BMS__StartJobByTimeType();
    virtual BMS__StartJobType *_kd_clone() const;

public:
    BMS__StartJobByTimeType( const BMS__StartJobByTimeType& );
    BMS__StartJobByTimeType &operator=( const BMS__StartJobByTimeType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Characteristics of files, video, audio and ancillary data.
 */
class BMS__FormatType : public BMS__ResourceType
{
public:
    void setTechnicalAttribute( const QList< BMS__TechnicalAttributeType >& technicalAttribute );
    QList< BMS__TechnicalAttributeType > technicalAttribute() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__FormatType();
    virtual ~BMS__FormatType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__FormatType( const BMS__FormatType& );
    BMS__FormatType &operator=( const BMS__FormatType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Describes a job, which is extended in each service schema.RequiredSupported
    job commands
 */
class BMS__JobType : public BMS__ResourceType
{
public:
    void setStatus( const BMS__JobStatusType& status );
    BMS__JobStatusType status() const;
    void setStatusDescription( const QString& statusDescription );
    QString statusDescription() const;
    void setServiceProviderJobID( const QString& serviceProviderJobID );
    QString serviceProviderJobID() const;
    void setQueueReference( const BMS__QueueType& queueReference );
    BMS__QueueType queueReference() const;
    void setTasks( const BMS__JobsType& tasks );
    BMS__JobsType tasks() const;
    void setOperationName( const QString& operationName );
    QString operationName() const;
    void setBmObjects( const BMS__BMObjectsType& bmObjects );
    BMS__BMObjectsType bmObjects() const;
    void setPriority( const BMS__PriorityType& priority );
    BMS__PriorityType priority() const;
    KDSoapValue startJob_as_kdsoap_value() const;
    void setStartJob( const BMS__StartJobType& startJob );
    const BMS__StartJobType &startJob() const;
    void setFinishBefore( const KDDateTime& finishBefore );
    KDDateTime finishBefore() const;
    void setEstimatedCompletionDuration( const QString& estimatedCompletionDuration );
    QString estimatedCompletionDuration() const;
    void setCurrentQueuePosition( quint64 currentQueuePosition );
    quint64 currentQueuePosition() const;
    void setJobStartedTime( const KDDateTime& jobStartedTime );
    KDDateTime jobStartedTime() const;
    void setJobElapsedTime( const QString& jobElapsedTime );
    QString jobElapsedTime() const;
    void setJobCompletedTime( const KDDateTime& jobCompletedTime );
    KDDateTime jobCompletedTime() const;
    KDSoapValue processed_as_kdsoap_value() const;
    void setProcessed( const BMS__ProcessedInfoType& processed );
    const BMS__ProcessedInfoType &processed() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__JobType();
    virtual ~BMS__JobType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__JobType( const BMS__JobType& );
    BMS__JobType &operator=( const BMS__JobType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __TargetAudience : public __TextElementType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __TargetAudience();
    ~__TargetAudience();

};

/**
    Describes a transform job.
 */
class TFMS__TransformJobType : public BMS__JobType
{
public:
    void setProfiles( const TFMS__Profiles& profiles );
    TFMS__Profiles profiles() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    TFMS__TransformJobType();
    ~TFMS__TransformJobType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    TFMS__TransformJobType( const TFMS__TransformJobType& );
    TFMS__TransformJobType &operator=( const TFMS__TransformJobType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Format description and essence locations of a physical representation of
    single rendition of a logical content item.
 */
class BMS__BMContentFormatType : public BMS__ResourceType
{
public:
    void setBmEssenceLocators( const BMS__BMEssenceLocatorsType& bmEssenceLocators );
    BMS__BMEssenceLocatorsType bmEssenceLocators() const;
    void setFormatCollection( const BMS__FormatCollection& formatCollection );
    BMS__FormatCollection formatCollection() const;
    void setDuration( const BMS__DurationType& duration );
    BMS__DurationType duration() const;
    void setHash( const BMS__HashType& hash );
    BMS__HashType hash() const;
    void setPackageSize( quint64 packageSize );
    quint64 packageSize() const;
    void setMimeType( const BMS__MimeType& mimeType );
    BMS__MimeType mimeType() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__BMContentFormatType();
    ~BMS__BMContentFormatType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__BMContentFormatType( const BMS__BMContentFormatType& );
    BMS__BMContentFormatType &operator=( const BMS__BMContentFormatType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Container/wrapper format that is used in complement to the streams
    encoding, for example MXF, wave, Quicktime, etc.. See 'fileFormat' in EBU
    Tech 3293 for more information.
 */
class BMS__ContainerFormatType : public BMS__FormatType
{
public:
    void setContainerFormat( const BMS__ContainerFormat& containerFormat );
    BMS__ContainerFormat containerFormat() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ContainerFormatType();
    ~BMS__ContainerFormatType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__ContainerFormatType( const BMS__ContainerFormatType& );
    BMS__ContainerFormatType &operator=( const BMS__ContainerFormatType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    This type is part of the FIMS service common status interface and provides
    a mechanism query jobs and retrieve information associated to them. A
    client can request the status of jobs that meet requirements specified by a
    filter object.
 */
class BMS__QueryJobRequestByFilterType : public BMS__QueryJobRequestType
{
public:
    void setListFilter( const BMS__ListFilterType& listFilter );
    BMS__ListFilterType listFilter() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__QueryJobRequestByFilterType();
    ~BMS__QueryJobRequestByFilterType();
    virtual BMS__QueryJobRequestType *_kd_clone() const;

public:
    BMS__QueryJobRequestByFilterType( const BMS__QueryJobRequestByFilterType& );
    BMS__QueryJobRequestByFilterType &operator=( const BMS__QueryJobRequestByFilterType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __ObjectType : public __TextElementType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __ObjectType();
    ~__ObjectType();

};

/**
    Description of a logical content, containing descriptive metadata.
    Descriptive metadata is attached using the proposed core XML description
    based on EBUCore or using the schema "any" facility supported by all
    resources.
 */
class BMS__DescriptionType : public BMS__ResourceType
{
public:
    void setBmContentDescription( const __BmContentDescriptionType& bmContentDescription );
    __BmContentDescriptionType bmContentDescription() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__DescriptionType();
    ~BMS__DescriptionType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__DescriptionType( const BMS__DescriptionType& );
    BMS__DescriptionType &operator=( const BMS__DescriptionType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __TitleType : public __TextElementType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __TitleType();
    ~__TitleType();

};

/**
    Characteristics of an audio signal. See 'audioFormat' in EBU Tech 3293 for
    more information.
 */
class BMS__AudioFormatType : public BMS__FormatType
{
public:
    void setSamplingRate( float samplingRate );
    float samplingRate() const;
    void setAudioEncoding( const BMS__CodecType& audioEncoding );
    BMS__CodecType audioEncoding() const;
    void setTrackConfiguration( const BMS__TrackConfiguration& trackConfiguration );
    BMS__TrackConfiguration trackConfiguration() const;
    void setAudioTrack( const QList< BMS__BMTrackType >& audioTrack );
    QList< BMS__BMTrackType > audioTrack() const;
    void setChannels( quint64 channels );
    quint64 channels() const;
    void setBitRate( quint64 bitRate );
    quint64 bitRate() const;
    void setBitRateMode( const BMS__BitRateModeType& bitRateMode );
    BMS__BitRateModeType bitRateMode() const;
    void setSampleSize( quint64 sampleSize );
    quint64 sampleSize() const;
    void setSampleType( const BMS__AudioSampleType& sampleType );
    BMS__AudioSampleType sampleType() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__AudioFormatType();
    ~BMS__AudioFormatType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__AudioFormatType( const BMS__AudioFormatType& );
    BMS__AudioFormatType &operator=( const BMS__AudioFormatType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Statistics on number of frames processed.
 */
class BMS__ProcessedInfoByFramesType : public BMS__ProcessedInfoType
{
public:
    void setProcessedFramesCount( quint64 processedFramesCount );
    quint64 processedFramesCount() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ProcessedInfoByFramesType();
    ~BMS__ProcessedInfoByFramesType();
    virtual BMS__ProcessedInfoType *_kd_clone() const;

public:
    BMS__ProcessedInfoByFramesType( const BMS__ProcessedInfoByFramesType& );
    BMS__ProcessedInfoByFramesType &operator=( const BMS__ProcessedInfoByFramesType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Fault information for the transform media service.If an exception is
    generated when the transform request message is submitted to the service,
    it shall respond with a message based on the TransformFaultType.
 */
class TFMS__TransformFaultType : public BMS__FaultType
{
public:
    void setExtendedCode( const TFMS__TransformErrorCodeType& extendedCode );
    TFMS__TransformErrorCodeType extendedCode() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    TFMS__TransformFaultType();
    ~TFMS__TransformFaultType();
    virtual BMS__FaultType *_kd_clone() const;

public:
    TFMS__TransformFaultType( const TFMS__TransformFaultType& );
    TFMS__TransformFaultType &operator=( const TFMS__TransformFaultType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

//class KD_TMFS__ExceptionFactory
//{
//public:
//    //static QPair<QString,QString> faultNameAndNamespace(const KDSoapValue& detail );

//};


class TransformFaultExceptionPrivate;

class TransformFaultException : public KDSoapFaultException {
public:
    TransformFaultException();
    TransformFaultException(const TransformFaultException& cpy);
    TransformFaultException(const QString &faultCode, const QString &faultString, const QString &faultActor, const TFMS__TransformFaultType &faultType);
    TransformFaultException &operator=( const TransformFaultException & );
    virtual ~TransformFaultException();

    KDSoapValue serialize( const QString& valueName ) const ;
    void deserialize( const KDSoapValue& mainValue );

    TFMS__TransformFaultType faultType() const;
    static QString faultElementName();
    static QString faultElementNameSpace();

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
//    TransformFaultExceptionPrivate* d_ptr;
};
Q_DECLARE_METATYPE(TransformFaultException)
Q_DECLARE_METATYPE(TransformFaultException*)

/**
    Start a job as soon as possible.The job shall start without waiting for a
    specific time or event. This type shall be supported.
 */
class BMS__StartJobByNoWaitType : public BMS__StartJobType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__StartJobByNoWaitType();
    ~BMS__StartJobByNoWaitType();
    virtual BMS__StartJobType *_kd_clone() const;

};

class __SubjectType : public __TextElementType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __SubjectType();
    ~__SubjectType();

};

class __Temporal : public __TextElementType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __Temporal();
    ~__Temporal();

};

/**
    Location of a physical representation of an item of content. Note that
    essence locations may be shared by multiple physical content formats and/or
    logical content items. For example, a folder structure taken from a camera
    may contain both master-quality and proxy-quality versions. The same
    essence locator can be targeted by two different physical content formats
    for the same logical content item. As another example, an AS-02 bundle may
    contain two different editorial versions of the same programme and can be
    referenced from two separate logical content items.An essence locator may
    be the target of more than one references from a content format.
 */
class BMS__BMEssenceLocatorType : public BMS__ResourceType
{
public:
    void setStorageType( const BMS__StorageType& storageType );
    BMS__StorageType storageType() const;
    void setLocatorInfo( const QString& locatorInfo );
    QString locatorInfo() const;
    void setContainerMimeType( const BMS__ContainerMimeType& containerMimeType );
    BMS__ContainerMimeType containerMimeType() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__BMEssenceLocatorType();
    virtual ~BMS__BMEssenceLocatorType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__BMEssenceLocatorType( const BMS__BMEssenceLocatorType& );
    BMS__BMEssenceLocatorType &operator=( const BMS__BMEssenceLocatorType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

class __DescriptionType : public __TextElementType
{
public:
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    __DescriptionType();
    ~__DescriptionType();

};

namespace TransformMediaService {
    namespace TransformMediaBindingJobs {
        class TransformJob : public KDSoapJob
        {
            Q_OBJECT

        public:
            TransformJob( TransformMediaService::TransformMediaBinding* service, QObject* parent = 0 );
            void setIn( const TFMS__TransformRequestType& arg0 );
            TFMS__TransformRequestType in() const;
            TFMS__TransformResponseType ack() const;

        protected:
            void doStart();

        private Q_SLOTS:
            void slotFinished( KDSoapPendingCallWatcher* watcher );

        private:
            TransformMediaService::TransformMediaBinding *mService;
            TFMS__TransformRequestType mIn;
            TFMS__TransformResponseType mResultAck;
};
} // namespace end
} // namespace end

namespace TransformMediaService {
    namespace TransformMediaStatusBindingJobs {
        class ManageJobJob : public KDSoapJob
        {
            Q_OBJECT

        public:
            ManageJobJob( TransformMediaService::TransformMediaStatusBinding* service, QObject* parent = 0 );
            void setIn( const BMS__ManageJobRequestType& arg0 );
            BMS__ManageJobRequestType in() const;
            BMS__ManageJobResponseType out() const;

        protected:
            void doStart();

        private Q_SLOTS:
            void slotFinished( KDSoapPendingCallWatcher* watcher );

        private:
            TransformMediaService::TransformMediaStatusBinding *mService;
            BMS__ManageJobRequestType mIn;
            BMS__ManageJobResponseType mResultOut;
};
} // namespace end
} // namespace end

namespace TransformMediaService {
    namespace TransformMediaStatusBindingJobs {
        class ManageQueueJob : public KDSoapJob
        {
            Q_OBJECT

        public:
            ManageQueueJob( TransformMediaService::TransformMediaStatusBinding* service, QObject* parent = 0 );
            void setIn( const BMS__ManageQueueRequestType& arg0 );
            BMS__ManageQueueRequestType in() const;
            BMS__ManageQueueResponseType out() const;

        protected:
            void doStart();

        private Q_SLOTS:
            void slotFinished( KDSoapPendingCallWatcher* watcher );

        private:
            TransformMediaService::TransformMediaStatusBinding *mService;
            BMS__ManageQueueRequestType mIn;
            BMS__ManageQueueResponseType mResultOut;
};
} // namespace end
} // namespace end

namespace TransformMediaService {
    namespace TransformMediaStatusBindingJobs {
        class QueryJobJob : public KDSoapJob
        {
            Q_OBJECT

        public:
            QueryJobJob( TransformMediaService::TransformMediaStatusBinding* service, QObject* parent = 0 );
            void setIn( const BMS__QueryJobRequestType& arg0 );
            BMS__QueryJobRequestType in() const;
            BMS__QueryJobResponseType out() const;

        protected:
            void doStart();

        private Q_SLOTS:
            void slotFinished( KDSoapPendingCallWatcher* watcher );

        private:
            TransformMediaService::TransformMediaStatusBinding *mService;
            BMS__QueryJobRequestType mIn;
            BMS__QueryJobResponseType mResultOut;
};
} // namespace end
} // namespace end

/**
    Provides basic queue information, such as the status and length of the
    queue.RequiredSupport or not the queue, queue depth, and supported queue
    commands
 */
class BMS__QueueType : public BMS__ResourceType
{
public:
    void setStatus( const BMS__QueueStatusType& status );
    BMS__QueueStatusType status() const;
    void setStatusDescription( const QString& statusDescription );
    QString statusDescription() const;
    void setLength( quint64 length );
    quint64 length() const;
    void setAvailability( bool availability );
    bool availability() const;
    void setEstimatedTotalCompletionDuration( const QString& estimatedTotalCompletionDuration );
    QString estimatedTotalCompletionDuration() const;
    void setJobs( const BMS__JobsType& jobs );
    BMS__JobsType jobs() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__QueueType();
    ~BMS__QueueType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__QueueType( const BMS__QueueType& );
    BMS__QueueType &operator=( const BMS__QueueType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Logical items of content, representing a sequence of frames and/or samples
    that have a fixed length and are intended to be played sequentially from
    end-to-end.Logical content items should be used to representing a single
    version of a programme or clip that has many different renditions, e.g.
    different encodings. Logical content items shall not be used to represent
    different editorial versions of content, such as a different cut of a
    programme created for a different audience.
 */
class BMS__BMContentType : public BMS__ResourceType
{
public:
    void setBmContentFormats( const BMS__BMContentFormatsType& bmContentFormats );
    BMS__BMContentFormatsType bmContentFormats() const;
    void setDescriptions( const BMS__DescriptionsType& descriptions );
    BMS__DescriptionsType descriptions() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__BMContentType();
    ~BMS__BMContentType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__BMContentType( const BMS__BMContentType& );
    BMS__BMContentType &operator=( const BMS__BMContentType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Characteristics of a data signal, used to carry captioning or ancillary
    data.
 */
class BMS__DataFormatType : public BMS__FormatType
{
public:
    void setCaptioningFormat( const QList< BMS__CaptioningFormatType >& captioningFormat );
    QList< BMS__CaptioningFormatType > captioningFormat() const;
    void setAncillaryDataFormat( const QList< BMS__AncillaryDataFormatType >& ancillaryDataFormat );
    QList< BMS__AncillaryDataFormatType > ancillaryDataFormat() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__DataFormatType();
    ~BMS__DataFormatType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__DataFormatType( const BMS__DataFormatType& );
    BMS__DataFormatType &operator=( const BMS__DataFormatType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    A profile used by a FIMS media service to perform a job on media content.
    For example, it may represent the profile of a transfer media service for
    transferring media content and, as such, may specify the media format to be
    produced in output. The profile provides a mechanism to specify
    service-provider-specific information for each operation.
 */
class BMS__ProfileType : public BMS__ResourceType
{
public:
    void setService( const BMS__ServiceType& service );
    BMS__ServiceType service() const;
    void setName( const QString& name );
    QString name() const;
    void setDescription( const QString& description );
    QString description() const;
    virtual KDSoapValue serialize( const QString& valueName ) const;
    virtual void deserialize( const KDSoapValue& mainValue );
    BMS__ProfileType();
    virtual ~BMS__ProfileType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__ProfileType( const BMS__ProfileType& );
    BMS__ProfileType &operator=( const BMS__ProfileType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Describes the location endpoint, provider and Service Description of the
    service.
 */
class BMS__ServiceType : public BMS__ResourceType
{
public:
    void setProviderName( const QString& providerName );
    QString providerName() const;
    void setProviderEndPoint( const QString& providerEndPoint );
    QString providerEndPoint() const;
    void setServiceDescription( const BMS__ServiceDescription& serviceDescription );
    BMS__ServiceDescription serviceDescription() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ServiceType();
    ~BMS__ServiceType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__ServiceType( const BMS__ServiceType& );
    BMS__ServiceType &operator=( const BMS__ServiceType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Characteristics of a video signal. See 'videoFormat' in EBU Tech 3293 for
    more information.
 */
class BMS__VideoFormatType : public BMS__FormatType
{
public:
    void setDisplayWidth( const BMS__LengthType& displayWidth );
    BMS__LengthType displayWidth() const;
    void setDisplayHeight( const BMS__LengthType& displayHeight );
    BMS__LengthType displayHeight() const;
    void setFrameRate( const BMS__RationalType& frameRate );
    BMS__RationalType frameRate() const;
    void setAspectRatio( const BMS__RationalType& aspectRatio );
    BMS__RationalType aspectRatio() const;
    void setVideoEncoding( const BMS__CodecType& videoEncoding );
    BMS__CodecType videoEncoding() const;
    void setVideoTrack( const QList< BMS__BMTrackType >& videoTrack );
    QList< BMS__BMTrackType > videoTrack() const;
    void setBitRate( quint64 bitRate );
    quint64 bitRate() const;
    void setBitRateMode( const BMS__BitRateModeType& bitRateMode );
    BMS__BitRateModeType bitRateMode() const;
    void setLines( quint64 lines );
    quint64 lines() const;
    void setScanningFormat( const BMS__ScanningFormatType& scanningFormat );
    BMS__ScanningFormatType scanningFormat() const;
    void setScanningOrder( const BMS__ScanningOrderType& scanningOrder );
    BMS__ScanningOrderType scanningOrder() const;
    void setNoiseFilter( bool noiseFilter );
    bool noiseFilter() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__VideoFormatType();
    ~BMS__VideoFormatType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__VideoFormatType( const BMS__VideoFormatType& );
    BMS__VideoFormatType &operator=( const BMS__VideoFormatType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Location of essence represented by a single file
 */
class BMS__SimpleFileLocatorType : public BMS__BMEssenceLocatorType
{
public:
    void setFile( const QString& file );
    QString file() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__SimpleFileLocatorType();
    ~BMS__SimpleFileLocatorType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__SimpleFileLocatorType( const BMS__SimpleFileLocatorType& );
    BMS__SimpleFileLocatorType &operator=( const BMS__SimpleFileLocatorType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Root of a folder structure that, taken as a whole including its children,
    represents an essence location that stores the rendition of the content
    described by the parent content format.The folder and all of its children
    should be presented within a single filing system.
 */
class BMS__FolderLocatorType : public BMS__BMEssenceLocatorType
{
public:
    void setFolder( const QString& folder );
    QString folder() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__FolderLocatorType();
    ~BMS__FolderLocatorType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__FolderLocatorType( const BMS__FolderLocatorType& );
    BMS__FolderLocatorType &operator=( const BMS__FolderLocatorType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Location of essence represented by a list of files that represent a single
    rendition of the content.
 */
class BMS__ListFileLocatorType : public BMS__BMEssenceLocatorType
{
public:
    void setFile( const QStringList& file );
    QStringList file() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    BMS__ListFileLocatorType();
    ~BMS__ListFileLocatorType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    BMS__ListFileLocatorType( const BMS__ListFileLocatorType& );
    BMS__ListFileLocatorType &operator=( const BMS__ListFileLocatorType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

/**
    Profile used by the transform media service to perform a transformation on
    media content. The profile specifies the media format to be output.
 */
class TFMS__TransformProfileType : public BMS__ProfileType
{
public:
    void setTransformAtom( const BMS__TransformAtomType& transformAtom );
    BMS__TransformAtomType transformAtom() const;
    void setTransferAtom( const QList< BMS__TransferAtomType >& transferAtom );
    QList< BMS__TransferAtomType > transferAtom() const;
    void setOutputFileNamePattern( const QString& outputFileNamePattern );
    QString outputFileNamePattern() const;
    KDSoapValue serialize( const QString& valueName ) const;
    void deserialize( const KDSoapValue& mainValue );
    TFMS__TransformProfileType();
    ~TFMS__TransformProfileType();
    virtual BMS__ResourceReferenceType *_kd_clone() const;

public:
    TFMS__TransformProfileType( const TFMS__TransformProfileType& );
    TFMS__TransformProfileType &operator=( const TFMS__TransformProfileType& );

private:
    class PrivateDPtr;
    QSharedDataPointer<PrivateDPtr> d_ptr;
};

namespace TransformMediaService {
    class TransformMediaBinding : public QObject
    {
        Q_OBJECT

    public:
        TransformMediaBinding( QObject* parent = 0 );
        ~TransformMediaBinding();
        /**
            Asks Qt to ignore ssl errors in https requests. Use this for
            testing only!
         */
        void ignoreSslErrors();
        /**
            Overwrite the end point defined in the .wsdl file, with another
            http/https URL.
         */
        void setEndPoint( const QString& endPoint );
        /**
            Overwrite the soap version defined in the .wsdl file, with another
            version.
            version can be KDSoapClientInterface::SOAP1_1 or
            KDSoapClientInterface::SOAP1_2
         */
        void setSoapVersion( KDSoapClientInterface::SoapVersion soapVersion );
        /**
            Return the error from the last blocking call.
            Empty if no error.
         */
        QString lastError() const;
        /**
            Returns the underlying KDSoapClientInterface instance, which allows
            to access setCookieJar, lastResponseHeaders, etc.
         */
        const KDSoapClientInterface *clientInterface() const;
        KDSoapClientInterface *clientInterface();
        /**
            Blocking call to transform.
            Not recommended in a GUI thread.
         */
        TFMS__TransformResponseType transform( const TFMS__TransformRequestType& in );
        /**
            Asynchronous call to transform.
            Remember to connect to transformDone and transformError.
         */
        void asyncTransform( const TFMS__TransformRequestType& in );

    Q_SIGNALS:
        /**
            This signal is emitted whenever a SOAP call failed, for a central
            processing of all SOAP errors.
            method is the name of the method (or operation) that returned the
            fault, for instance "addContact".
         */
        void soapError( const QString& method, const KDSoapMessage& fault );
        /**
            This signal is emitted whenever the call to transform() succeeded.
         */
        void transformDone( const TFMS__TransformResponseType& ack );
        /**
            This signal is emitted whenever the call to transform() failed.
         */
        void transformError( const KDSoapMessage& fault );

    private Q_SLOTS:
        void _kd_slotTransformFinished( KDSoapPendingCallWatcher* watcher );

    private:
        class PrivateDPtr;
        PrivateDPtr *d_ptr;
};
} // namespace end

namespace TransformMediaService {
    class TransformMediaStatusBinding : public QObject
    {
        Q_OBJECT

    public:
        TransformMediaStatusBinding( QObject* parent = 0 );
        ~TransformMediaStatusBinding();
        /**
            Asks Qt to ignore ssl errors in https requests. Use this for
            testing only!
         */
        void ignoreSslErrors();
        /**
            Overwrite the end point defined in the .wsdl file, with another
            http/https URL.
         */
        void setEndPoint( const QString& endPoint );
        /**
            Overwrite the soap version defined in the .wsdl file, with another
            version.
            version can be KDSoapClientInterface::SOAP1_1 or
            KDSoapClientInterface::SOAP1_2
         */
        void setSoapVersion( KDSoapClientInterface::SoapVersion soapVersion );
        /**
            Return the error from the last blocking call.
            Empty if no error.
         */
        QString lastError() const;
        /**
            Returns the underlying KDSoapClientInterface instance, which allows
            to access setCookieJar, lastResponseHeaders, etc.
         */
        const KDSoapClientInterface *clientInterface() const;
        KDSoapClientInterface *clientInterface();
        /**
            Blocking call to manageJob.
            Not recommended in a GUI thread.
         */
        BMS__ManageJobResponseType manageJob( const BMS__ManageJobRequestType& in );
        /**
            Asynchronous call to manageJob.
            Remember to connect to manageJobDone and manageJobError.
         */
        void asyncManageJob( const BMS__ManageJobRequestType& in );
        /**
            Blocking call to manageQueue.
            Not recommended in a GUI thread.
         */
        BMS__ManageQueueResponseType manageQueue( const BMS__ManageQueueRequestType& in );
        /**
            Asynchronous call to manageQueue.
            Remember to connect to manageQueueDone and manageQueueError.
         */
        void asyncManageQueue( const BMS__ManageQueueRequestType& in );
        /**
            Blocking call to queryJob.
            Not recommended in a GUI thread.
         */
        BMS__QueryJobResponseType queryJob( const BMS__QueryJobRequestType& in );
        /**
            Asynchronous call to queryJob.
            Remember to connect to queryJobDone and queryJobError.
         */
        void asyncQueryJob( const BMS__QueryJobRequestType& in );

    Q_SIGNALS:
        /**
            This signal is emitted whenever a SOAP call failed, for a central
            processing of all SOAP errors.
            method is the name of the method (or operation) that returned the
            fault, for instance "addContact".
         */
        void soapError( const QString& method, const KDSoapMessage& fault );
        /**
            This signal is emitted whenever the call to manageJob() succeeded.
         */
        void manageJobDone( const BMS__ManageJobResponseType& out );
        /**
            This signal is emitted whenever the call to manageJob() failed.
         */
        void manageJobError( const KDSoapMessage& fault );
        /**
            This signal is emitted whenever the call to manageQueue()
            succeeded.
         */
        void manageQueueDone( const BMS__ManageQueueResponseType& out );
        /**
            This signal is emitted whenever the call to manageQueue() failed.
         */
        void manageQueueError( const KDSoapMessage& fault );
        /**
            This signal is emitted whenever the call to queryJob() succeeded.
         */
        void queryJobDone( const BMS__QueryJobResponseType& out );
        /**
            This signal is emitted whenever the call to queryJob() failed.
         */
        void queryJobError( const KDSoapMessage& fault );

    private Q_SLOTS:
        void _kd_slotManageJobFinished( KDSoapPendingCallWatcher* watcher );
        void _kd_slotManageQueueFinished( KDSoapPendingCallWatcher* watcher );
        void _kd_slotQueryJobFinished( KDSoapPendingCallWatcher* watcher );

    private:
        class PrivateDPtr;
        PrivateDPtr *d_ptr;
};
} // namespace end

class TransformMediaNotificationService : public QObject
{
    Q_OBJECT

public:
    TransformMediaNotificationService( QObject* parent = 0 );
    ~TransformMediaNotificationService();
    /**
        Asks Qt to ignore ssl errors in https requests. Use this for testing
        only!
     */
    void ignoreSslErrors();
    /**
        Overwrite the end point defined in the .wsdl file, with another
        http/https URL.
     */
    void setEndPoint( const QString& endPoint );
    /**
        Overwrite the soap version defined in the .wsdl file, with another
        version.
        version can be KDSoapClientInterface::SOAP1_1 or
        KDSoapClientInterface::SOAP1_2
     */
    void setSoapVersion( KDSoapClientInterface::SoapVersion soapVersion );
    /**
        Return the error from the last blocking call.
        Empty if no error.
     */
    QString lastError() const;
    /**
        Returns the underlying KDSoapClientInterface instance, which allows to
        access setCookieJar, lastResponseHeaders, etc.
     */
    const KDSoapClientInterface *clientInterface() const;
    KDSoapClientInterface *clientInterface();
    /**
        Blocking call to notifyTransformResult.
        Not recommended in a GUI thread.
     */
    void notifyTransformResult( const TFMS__TransformNotificationType& in );
    /**
        Asynchronous call to notifyTransformResult.
        Remember to connect to notifyTransformResultDone and
        notifyTransformResultError.
     */
    void asyncNotifyTransformResult( const TFMS__TransformNotificationType& in );
    /**
        Blocking call to notifyFault.
        Not recommended in a GUI thread.
     */
    void notifyFault( const TFMS__TransformFaultNotificationType& fault );
    /**
        Asynchronous call to notifyFault.
        Remember to connect to notifyFaultDone and notifyFaultError.
     */
    void asyncNotifyFault( const TFMS__TransformFaultNotificationType& fault );

Q_SIGNALS:
    /**
        This signal is emitted whenever a SOAP call failed, for a central
        processing of all SOAP errors.
        method is the name of the method (or operation) that returned the
        fault, for instance "addContact".
     */
    void soapError( const QString& method, const KDSoapMessage& fault );
    /**
        This signal is emitted whenever the call to notifyTransformResult()
        succeeded.
     */
    void notifyTransformResultDone();
    /**
        This signal is emitted whenever the call to notifyTransformResult()
        failed.
     */
    void notifyTransformResultError( const KDSoapMessage& fault );
    /**
        This signal is emitted whenever the call to notifyFault() succeeded.
     */
    void notifyFaultDone();
    /**
        This signal is emitted whenever the call to notifyFault() failed.
     */
    void notifyFaultError( const KDSoapMessage& fault );

private Q_SLOTS:
    void _kd_slotNotifyTransformResultFinished( KDSoapPendingCallWatcher* watcher );
    void _kd_slotNotifyFaultFinished( KDSoapPendingCallWatcher* watcher );

private:
    class PrivateDPtr;
    PrivateDPtr *d_ptr;
};

#endif
